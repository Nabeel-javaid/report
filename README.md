# üõ†Ô∏è Wise Lending
**Decentralized liquidity market that allows users to supply crypto assets and start earning a variable APY from borrowers.**

## Overview of the protocol
The wiseLending protocol presents itself as a sophisticated construct within the Ethereum blockchain ecosystem, designed to intricately blend traditional DeFi lending models with an advanced leveraged farming mechanism. This melding of functionalities aims to redefine the user experience in the DeFi space by offering a more granular control over asset management and yield optimization.

Initiating the user journey with the fundamental act of depositing assets into the protocol, wiseLending leverages these deposits either as collateral for loans or as stakes in yield farming activities. This is where the project distinguishes itself, particularly through the integration with Aave for lending services and the novel implementation of the PowerFarm feature for enhanced yield farming operations. The PowerFarm, specifically, allows users to employ leveraged positions in farming activities, thereby amplifying the potential returns on their staked assets.

Central to orchestrating this complex interaction of depositing, borrowing, and farming is the suite of smart contracts developed for the protocol. Notably, contracts such as AaveHelper and PendlePowerFarm play crucial roles. AaveHelper facilitates seamless interactions with the Aave lending platform, enabling users to borrow against their deposits or earn interest. On the other hand, the PendlePowerFarm contract manages the leveraged yield farming activities, optimizing strategies to maximize user returns from staked assets.

Moreover, the protocol's design encompasses mechanisms for tokenizing yield through its partnership with Pendle, adding another layer of strategic asset management. This feature allows users to capitalize on future yield prospects, further enhancing the utility and flexibility of their investments within the platform.

The intricate web of functionalities, from asset deposits to strategy optimization for leveraged farming, is underpinned by robust governance structures ensured through contracts like OwnableMaster. This governance framework secures the protocol's integrity, operational

<br/>

[![Screenshot-from-2024-03-11-19-04-35.png](https://i.postimg.cc/9FSnCMKk/Screenshot-from-2024-03-11-19-04-35.png)](https://postimg.cc/GHFQjccP)

## Approach taken while auditing the codebase
When I began the audit of the wiseLending protocol, my first step was to dive into the documentation provided. This crucial step helped me understand the protocol's intended functionality, architecture, and key components. I also reviewed any previous audit reports available. These reports offered insights into past vulnerabilities, how they were addressed, and areas that might require extra scrutiny.

Next, I systematically went through each smart contract provided, starting with the core contracts like `AaveHelper.sol`, `PositionNFTs.sol`, and `Declarations.sol`. I looked at the contracts' structure, inheritance patterns, and how they interact with external contracts and protocols. Understanding the flow between contracts was essential, so I paid close attention to function calls that crossed contract boundaries, ensuring they were properly authenticated and validated.

I then focused on the contracts managing user interactions, such as those related to lending, borrowing, and yield farming strategies. Here, I was particularly vigilant about identifying any functions that could be exploited due to reentrancy attacks, improper access controls, or mishandling of user funds.

The contracts related to oracles and price feeds, like `PendleLpOracle.sol` and `PtOracleDerivative.sol`, were also a critical area of my audit. I checked for any issues that could arise from oracle manipulation or stale data, which could lead to incorrect price reporting and, consequently, impact the protocol's operations.

After the initial review, I moved on to testing the contracts for common vulnerabilities using both static analysis(my own bot) and manual testing. This involved looking for issues such as integer overflows/underflows, reentrancy, gas limit vulnerabilities, and more. I also performed behavioral testing to observe how the contracts interact under various scenarios, including edge cases.

In summary, my approach was methodical, starting from a comprehensive review of the documentation and previous audits, moving through a detailed examination of each contract, and conducting thorough testing for vulnerabilities. This structured approach ensured that I covered all aspects of the protocol, understanding its intended functionality, and identifying any areas of concern.

## Codebase Quality

Overall, I consider the quality of the wise lending protocol codebase to be Good. The code appears to be mature and well-developed. I have noticed the implementation of various standards adhere to appropriately. Details are explained below:

| Codebase Quality Categories              | Comments                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ---------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Documentation**                        | The codebase is accompanied by comprehensive documentation that clearly explains the purpose and functionality of each contract and function. Comments within the code are helpful for understanding the logic and flow, although there are areas where additional details could further clarify complex processes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| **Consistency**                          | The naming conventions, file structure, and coding style are consistent throughout the project, facilitating readability and maintainability. This consistency extends to the use of modifiers, error handling, and event logging, which are uniformly applied across the contracts.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| **Security Practices**                   | Security considerations are evident in the implementation of reentrancy guards, access controls, and checks-effects-interactions patterns. The use of well-established standards and libraries, such as OpenZeppelin for token standards and security utilities, adds to the robustness. However, the complexity of interactions between contracts, especially in the lending and borrowing mechanisms, necessitates rigorous security audits to ensure all edge cases and potential attack vectors are covered.                                                                                                                                                                                                                                                                           |
| **Testing and Coverage**                 | The protocol includes a suite of tests covering critical functionalities such as lending, borrowing, token transfers, and interaction with external protocols like AAVE. While the coverage is comprehensive for major flows, the addition of more tests for edge cases and stress conditions could further solidify confidence in the codebase's reliability.                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| **Optimization and Gas Efficiency**      | The code demonstrates awareness of gas optimization, with practices like minimizing state changes, using efficient data storage types, and optimizing loops and calculations. However, given the protocol's complexity and interactions with external contracts, there are inherent challenges in achieving optimal gas efficiency. Continuous efforts to identify and implement optimizations would be beneficial, especially as the protocol scales.                                                                                                                                                                                                                                                                                                                                  |
| **Modularity and Upgradability**         | The protocol is designed with modularity in mind, allowing for easier maintenance and future expansion. Contracts are well-separated by functionality, which helps isolate changes and reduces the risk of unintended side effects. The approach to upgradability is cautious, with a clear governance process for making changes to critical components. This careful balance between modularity and upgradability is crucial for maintaining security while allowing the protocol to evolve.                                                                                                                                                                                                                                                                                 |
| **Dependency Management**                | Dependencies on external contracts and libraries are carefully managed, with explicit versioning for solidity and imported libraries. This reduces the risk of breaking changes and vulnerabilities introduced through dependencies. The protocol's reliance on external oracles and protocols like AAVE is a necessary aspect of its functionality, but it also introduces dependencies that need to be monitored for updates and potential security issues.                                                                                                                                                                                                                                                                                                                               |
| **Community and Ecosystem Integration**  | The protocol integrates well with the broader DeFi ecosystem, leveraging established protocols for lending, borrowing, and price feeds. This not only enriches the protocol's offerings but also encourages interoperability within the DeFi space. Active engagement with the community through documentation, open-source code, and channels for feedback contributes positively to the protocol's development and adoption.                                                                                                                                                                                                                                                                                                                             |


### Core Contracts and Functions:

- **LendingPool**: This contract acts as the central hub where assets are deposited by lenders to earn interest and from where borrowers obtain loans by over-collateralizing their positions. Functions like `deposit()` allow lenders to supply assets to the pool, earning interest tokens in return, representing their share of the pool.

- **InterestRateModel**: Critical to determining the cost of borrowing, this contract encapsulates the logic for dynamically adjusting interest rates based on the current utilization rate of the pool (i.e., the ratio of total borrowed funds to total deposited funds). The model typically follows a curve that increases as the utilization rate grows, incentivizing early repayments and additional deposits when liquidity is low. The mathematical foundation here often involves a piecewise linear or exponential function designed to balance supply and demand within the protocol efficiently.

- **CollateralManager**: This contract oversees the valuation and management of collateral posted by borrowers. It utilizes price oracles (e.g., from the `IWiseOracleHub` contract) to ascertain real-time asset values and enforces a collateral factor (a safety margin above the loan value, often expressed as a percentage exceeding 100%). The collateral-to-loan ratio must always exceed this factor to prevent liquidation. Mathematically, if the collateral's market value, fetched from the oracle and adjusted for the collateral factor, falls below the value of the borrowed amount plus accrued interest, the position becomes vulnerable to liquidation.

- **LiquidationManager**: In scenarios where borrowers fail to maintain adequate collateral levels, this contract facilitates the liquidation process, allowing other participants to repay part or all of the under-collateralized loan at a discount, in exchange for receiving a portion of the collateral. The logic here often involves calculating the exact discount rate and the amount of collateral that can be liquidated in a single transaction, taking into account the protocol's liquidation threshold and incentive mechanisms to ensure rapid response from liquidators.

### Financial Formulas and Logic:

At the heart of the lending and borrowing mechanism are the formulas used to calculate interest rates, loan health, and liquidation parameters. The interest rate model might adopt an equation like:

\[ InterestRate = BaseRate + UtilizationRate * Multiplier \]

where `BaseRate` offers minimal returns to lenders at low utilization levels, and `Multiplier` scales the interest rate with utilization to ensure the pool's stability. For collateral valuation and liquidation thresholds, formulas ensure that:

\[ CollateralValue = AssetPrice * Quantity * CollateralFactor \]

\[ LiquidationTrigger = LoanValue * (1 + LiquidationThreshold) \]

Here, `CollateralFactor` adjusts the market value of the collateral to incorporate a safety margin, and `LiquidationThreshold` dictates when a loan is eligible for liquidation, based on its current health, defined as the ratio of collateral value to loan value.

